import nextcord
from nextcord.ext import commands
from datetime import datetime
from module import *
from pathlib import Path
from nextcord.utils import get
import json
import time
import option
import asyncio

options = ['ÌôòÏòÅÎ©îÏÑ∏ÏßÄ','ÏÑúÎ≤Ñ ÏûÖÏû•', 'ÏÑúÎ≤Ñ Ìá¥Ïû•', 'Î©îÏÑ∏ÏßÄ ÏÇ≠Ï†ú', 'Î©îÏÑ∏ÏßÄ ÏàòÏ†ï', 'Ï±ÑÎÑê ÏÉùÏÑ±', 'Ï±ÑÎÑê ÏÇ≠Ï†ú', 'Ïú†Ï†Ä Ïó≠Ìï† Î≥ÄÍ≤Ω', 'Ïú†Ï†Ä ÎãâÎÑ§ÏûÑ Î≥ÄÍ≤Ω', 'Ïó≠Ìï† ÏÉùÏÑ±', 'Ïó≠Ìï† ÏÇ≠Ï†ú', 'Ïó≠Ìï† Ïù¥Î¶Ñ Î≥ÄÍ≤Ω', 'Ïó≠Ìï† ÏÉâ Î≥ÄÍ≤Ω', 'Ïú†Ï†Ä Ï∞®Îã®', 'Ïú†Ï†Ä Ï∞®Îã® Ìï¥Ï†ú', 'Ï¥àÎåÄÏΩîÎìú ÏÉùÏÑ±', 'Ï¥àÎåÄÏΩîÎìú ÏÇ≠Ï†ú', 'Î≥¥Ïù¥Ïä§ Ï±ÑÎÑê ÏûÖÏû•', 'Î≥¥Ïù¥Ïä§ Ï±ÑÎÑê Ìá¥Ïû•']

#MONDAY TOKEN 
token = str(open("token.txt", "r").readline())

#Load Datas from json file
with open('data.json', 'r', encoding="UTF-8") as f:
    datas = json.load(f)

with open('guild.json', 'r', encoding="UTF-8") as g:
    guilds = json.load(g)

def update_guild():
    with open('guild.json', 'w', encoding='UTF-8') as g:
        json.dump(guilds, g, ensure_ascii=False)

#Settings of Monday 
intents = nextcord.Intents.all()
activity= [nextcord.Game, nextcord.Streaming, nextcord.Activity]
app = commands.AutoShardedBot(shard_count=1, command_prefix='', intents=intents, help_command=None)
app.version = '0.8.7'

#Colors of embed colors
colors = {'RED':0xFE0100, 
          'GREEN':0x05B430,
          'ORANGE':0xFFBF00,
          'MAIN':0x01A9DB}

#else Values 
nums = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0']

#Button 
class Confirm(nextcord.ui.View): 
    def __init__(self, user): 
        super().__init__()
        self.user = user
        self.value = None

    @nextcord.ui.button(label='ÏàòÎùΩ', style=nextcord.ButtonStyle.green)
    async def confirm(self, button:nextcord.ui.Button, interacation:nextcord.Interaction): 
        if self.user == interacation.user:
            self.value = True
            self.stop()

    @nextcord.ui.button(label='Í±∞Ï†à', style=nextcord.ButtonStyle.red)
    async def cancel(self, button:nextcord.ui.Button, interacation:nextcord.Interaction): 
        if self.user == interacation.user:
            self.value = False
            self.stop()

class Dropdown(nextcord.ui.Select): 
    def __init__(self, guild): 
        self.select_option = []

        with open('guild.json', 'r', encoding="UTF-8") as g:
                data_guild = json.load(g)

        if data_guild[guild]['LOG_OPTION'][0] == True: 
                state = 'üü¢'
                state_ex = 'ÌÅ¥Î¶≠ Ïãú ÎπÑÌôúÏÑ±Ìôî'
        else: 
            state = '‚ö™'
            state_ex = 'ÌÅ¥Î¶≠ Ïãú ÌôúÏÑ±Ìôî'

        self.select_option.append(nextcord.SelectOption(label=f'{options[0]} „Ö£ {state_ex}', description=f'Ïú†Ï†ÄÍ∞Ä ÏûÖÏû• Ïãú Î©îÏÑ∏ÏßÄ Ï†ÑÏÜ°', emoji=state))

        for i in range(1, len(options)):
            with open('guild.json', 'r', encoding="UTF-8") as g:
                data_guild = json.load(g)

            if data_guild[guild]['LOG_OPTION'][i] == True: 
                state = 'üü¢'
                state_ex = 'ÌÅ¥Î¶≠ Ïãú ÎπÑÌôúÏÑ±Ìôî'
            else: 
                state = '‚ö™'
                state_ex = 'ÌÅ¥Î¶≠ Ïãú ÌôúÏÑ±Ìôî'

            self.select_option.append(nextcord.SelectOption(label=f'{options[i]} „Ö£ {state_ex}', description=f'{options[i]} Ïãú Î°úÍπÖ', emoji=state))
        super().__init__(placeholder='ÏÑ§Ï†ïÌï† Î°úÍ∑∏Î•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.', min_values = 1, max_values = 1, options=self.select_option)

    async def callback(self, interaction:nextcord.Interaction): 
        guild = str(interaction.guild.id) 

        with open('guild.json', 'r', encoding="UTF-8") as g:
            data_guild = json.load(g)

        index = options.index(self.values[0].split(' „Ö£')[0]) 
        if data_guild[guild]['LOG_OPTION'][index] == True:
            guilds[guild]['LOG_OPTION'][index] = False
            state = '‚ö™'

        else: 
            guilds[guild]['LOG_OPTION'][index] = True
            state = 'üü¢'
            
        self.select_option[index] = nextcord.SelectOption(label=f'{options[index]}', description=f'{options[index]} Ïãú Î°úÍπÖ', emoji=state)
        update_guild() 

        settings = "" 

        for option in options: 
            with open('guild.json', 'r', encoding="UTF-8") as g:
                data_guild = json.load(g)

            if data_guild[str(interaction.guild.id)]['LOG_OPTION'][options.index(option)] == True: 
                state = 'ON'

            else: 
                state = 'OFF'

            settings += f"**{option}** Ïãú Î°úÍπÖ : `{state}`\n"

        embed = nextcord.Embed(title='Î°úÍ∑∏ ÏÑ§Ï†ï', description=settings, color=colors['MAIN'])
        await interaction.response.edit_message(embed=embed, view=DropdownView(guild))

        if self.values[0].split(' „Ö£')[0] == 'ÌôòÏòÅÎ©îÏÑ∏ÏßÄ' and data_guild[str(interaction.guild_id)]["LOG_OPTION"][0] == True: 
            embed = nextcord.Embed(title='ÌôòÏòÅÎ©îÏÑ∏ÏßÄ ÏÑ§Ï†ï', description='ÌôòÏòÅÎ©îÏÑ∏ÏßÄ ÏÑ§Ï†ïÏùÑ ÌïòÏãúÎ†§Î©¥ `ÌôòÏòÅÎ©îÏÑ∏ÏßÄÏÑ§Ï†ï`ÏùÑ ÏûÖÎ†•Ìï¥ ÏÑ§Ï†ïÌïòÏÑ∏Ïöî.') 
            embed.add_field(name='ÏûÖÏû• Î©îÏÑ∏ÏßÄ Ï†ÑÏÜ° Ï±ÑÎÑê', value=f'{app.get_channel(int(data_guild[str(interaction.guild.id)]["JOIN"]["CHANNEL"])).mention if data_guild[str(interaction.guild.id)]["JOIN"]["CHANNEL"] != None else "```ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏùå```"}', inline=False)
            embed.add_field(name='ÏûÖÏû• Ïãú Î©îÏÑ∏ÏßÄ', value=f'```{data_guild[str(interaction.guild_id)]["JOIN"]["MESSAGE"]}```', inline=False)
            embed.add_field(name='Ìá¥Ïû• Î©îÏÑ∏ÏßÄ Ï†ÑÏÜ° Ï±ÑÎÑê', value=f'{app.get_channel(int(data_guild[str(interaction.guild.id)]["EXIT"]["CHANNEL"])).mention if data_guild[str(interaction.guild.id)]["JOIN"]["CHANNEL"] != None else "```ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏùå```"}', inline=False)
            embed.add_field(name='Ìá¥Ïû• Ïãú Î©îÏÑ∏ÏßÄ', value=f'```{data_guild[str(interaction.guild_id)]["EXIT"]["MESSAGE"]}```', inline=False)
            await interaction.followup.send(embed=embed, ephemeral=True)

class DropdownView(nextcord.ui.View):
    def __init__(self, guild): 
        super().__init__()
        self.add_item(Dropdown(guild))

'''
class Pet(nextcord.ui.Modal):
    def __init__(self):
        super().__init__(
            "Your pet",
            timeout=5 * 60,  # 5 minutes
        )

        self.name = nextcord.ui.TextInput(
            label="Your pet's name",
            min_length=2,
            max_length=50,
        )
        self.add_item(self.name)

        self.description = nextcord.ui.TextInput(
            label="Description",
            style=nextcord.TextInputStyle.paragraph,
            placeholder="Information that can help us recognise your pet",
            required=False,
            max_length=1800,
        )
        self.add_item(self.description)

    async def callback(self, interaction: nextcord.Interaction) -> None:
        response = f"{interaction.user.mention}'s favourite pet's name is {self.name.value}."
        if self.description.value != "":
            response += f"\nTheir pet can be recognized by this information:\n{self.description.value}"
        await interaction.send(response)
'''

async def check_pattern(ctx, txt, tag): 
    returnValue = False

    with open('data.json', 'r', encoding="UTF-8") as f:
        data_intent = json.load(f)

    for data in data_intent: 
        if data['tag'] == tag: 
            if 'nonresponsible' in data['feature']:
                patterns = data['patterns'] 

                for pattern in patterns: 
                    if pattern in txt:
                        returnValue = True

                    else: 
                        pass

    return returnValue
            
async def check_promiss(ctx):
    if ctx.author.guild_permissions.administrator == True:
        return True

    else: 
        embed = nextcord.Embed(description='Ï†ëÍ∑ºÍ∂åÌïú Î∂ÄÏ°±', color=colors['RED']) 
        await ctx.send(embed=embed)

async def logging(guild:str, event, embed): 
    with open('guild.json', 'r', encoding="UTF-8") as g:
        data_guild = json.load(g)

    eventNum = int(options.index(event))
    if str(guild) in data_guild: 
        if data_guild[guild]["LOG_OPTION"][eventNum] == True:
            now = datetime.now()
            now = now.strftime('%Y-%m-%d %H:%M:%S')

            log = app.get_channel(int(data_guild[str(guild)]['LOG'])) 
            embed.add_field(name='TIMESTAMP', value=f'```{now}```', inline=False)
            await log.send(embed=embed)

async def send_log(guild, event, channel, user, content): 
    with open('guild.json', 'r', encoding="UTF-8") as g:
        data_guild = json.load(g)

    if str(guild) in data_guild:
        log = app.get_channel(int(data_guild[guild]['LOG']))

        embed = nextcord.Embed(title=f'{event}', color=colors['MAIN'])
        embed.add_field(name=f'**Ïú†Ï†Ä**', value=f'{user.mention}', inline=True)
        embed.add_field(name=f'**Ï±ÑÎÑê**', value=f'{channel.mention}')
        embed.add_field(name=f'**ÎÇ¥Ïö©**', value=f'```{content}```', inline=False)
        await log.send(embed=embed)

async def stats(ctx, txt):
    dpyVersion = nextcord.__version__
    serverCount = len(app.guilds)
    memberCount = len(set(app.get_all_members()))

    shardID = ctx.guild.shard_id
    shard = app.get_shard(shardID)
    shardPING = shard.latency
    shardSERVERS = len([guild for guild in app.guilds if guild.shard_id == shardID])

    embed = nextcord.Embed(title=f'{app.user.name} - Stats')

    embed.add_field(name='Bot Version:', value=f'```{app.version}```')
    embed.add_field(name='Discord.Py Version:', value=f'```{dpyVersion}```')
    embed.add_field(name='Total Guilds:', value=f'```{serverCount}```', inline=False)
    embed.add_field(name='Total Users:', value=f'```{memberCount}```')
    embed.add_field(name='Shard ID:', value=f'```{shardID}```', inline=False)
    embed.add_field(name='Shard Ping:', value=f'```{shardPING}```')
    embed.add_field(name='Shard Servers:', value=f'```{shardSERVERS}```')

    user = app.get_user(ctx.author.id)

    #embed.set_thumbnail(url=thumbnail)
    embed.set_author(name=user.display_name, icon_url=user.avatar)

    await ctx.send(embed=embed)
        
async def cal(ctx, txt): 
    operatorsWord = ['ÌîåÎü¨Ïä§', 'ÎçîÌïòÍ∏∞', 'ÎπºÍ∏∞', 'ÎßàÏù¥ÎÑàÏä§', 'ÎÇòÎàÑÍ∏∞', 'Í≥±ÌïòÍ∏∞']
    operators = ['+', '-', '*', '/'] 
    
    for operator in operatorsWord: 
        try: 
            if operator in 'ÌîåÎü¨Ïä§' or operator in 'ÎçîÌïòÍ∏∞':
                replaceOper = '+'

            elif operator in 'ÎπºÍ∏∞' or operator in 'ÎßàÏù¥ÎÑàÏä§':
                replaceOper = '-'

            elif operator in 'ÎÇòÎàÑÍ∏∞':
                replaceOper = '/'

            elif operator in 'Í≥±ÌïòÍ∏∞':
                replaceOper = '*'

            txt = txt.replace(operator, replaceOper) 

        except:
            pass

    txt = "".join(txt.split()) 

    expression= [] 
    numIndex = []
    
    for num in nums: 
        if num in txt: 
            index = txt.index(num) 
            numIndex.append(index)

        else: 
            pass

    if numIndex != []:
        index = min(numIndex) 

        expression.append(txt[index])
        for x in range(1, len(txt)+1): 
            if len(txt) > index+x:
                if txt[index+x] in nums: 
                    expression.append(txt[index+x]) 

                elif txt[index+x] in operators:
                    expression.append(txt[index+x])

                else:
                    break

            else:
                break

        expression = "".join(expression)

        embed = nextcord.Embed(title='Í≥ÑÏÇ∞', color=colors['GREEN']) 
        embed.add_field(name='Ïãù', value=f'```{expression}```')
        embed.add_field(name='Í≤∞Í≥º', value=f'```{eval(expression)}```')
        await ctx.send(embed=embed)

async def translate(ctx, txt): 
    transOptions = ["ÌïúÍ∏ÄÎ°ú", "ÏòÅÏñ¥Î°ú", "ÏùºÎ≥∏Ïñ¥Î°ú", "ÌïúÍµ≠Ïñ¥Î°ú", "ÏûâÍ∏ÄÎ¶¨Ïâ¨Î°ú", "ÏΩîÎ¶¨ÏïàÏúºÎ°ú", "ÏòÅÏñ¥", "ÌïúÍ∏Ä"]

    for transOption in transOptions:
        if transOption in txt.split():

            text = "".join("".join(txt.split()).split(transOption))
            print(text)
            if text.split('Î≤àÏó≠')[0] != '':
                text = " ".join(text.split('Î≤àÏó≠')[0].split())
            
            else: 
                text = " ".join(text.split('Î≤àÏó≠')[1].split())

            transOption = "".join(transOption.split('Î°ú')[0].split())

            break

        else: 
            transOption = 'ko'
            
            if txt.split('Î≤àÏó≠')[0] != '':
                text = " ".join(txt.split('Î≤àÏó≠')[0].split())
            
            else: 
                text = " ".join(txt.split('Î≤àÏó≠')[1].split())

    result = option.Translate().get_translate(text)
    await ctx.send(result)

async def check_ping(ctx, txt):
    try:
        ra1 = round(app.latency * 1000)

    except:
        pass

    embed = nextcord.Embed(title="Connection", color=colors['MAIN'])
    embed.add_field(name='Ping', value=f'```{str(ra1)}ms```')
    await ctx.send(embed=embed)

async def weather(ctx, txt):
    if 'ÎÇ†Ïî®' in txt: 
        searchOption = False
        
        scaleList = ['ÎèÑ', 'Ïãú', 'Íµ∞', 'Íµ¨', 'Îèô', 'Ïùç', 'Î©¥', 'Î¶¨']

        location = " ".join(txt.split('ÎÇ†Ïî®')[0].split())

        #print(location)
        #print(location[-1])

        if location[-1] in scaleList:
            #print('if')
            #print(len(location.split()))
            if len(location.split()) != 1: 
                for loc in location.split(): 
                    #print(loc)
                    if loc[-1] not in scaleList: 
                        location = " ".join("".join(location.split(loc)).split())

        else:
            location = None

        if 'ÏûêÏÑ∏Ìûà' in txt:
            searchOption = True

        info = option.Crawling().weather(location, searchOption)

        embed = nextcord.Embed(title=f'{info[0]}Ïùò ÎÇ†Ïî®', color=colors['MAIN']) 
        embed.add_field(name='Ïò®ÎèÑ', value=f'```{info[1]}C```')
        embed.add_field(name='ÏÑ§Î™Ö', value=f'```{info[2]}```', inline=False)

        if len(info) > 3:
            embed.add_field(name='Í∞ïÏàòÌôïÎ•†', value=f'```{info[3]}```')
            embed.add_field(name='ÏäµÎèÑ', value=f'```{info[4]}```')
            embed.add_field(name=f'Î∞îÎûå({info[6]})', value=f'```{info[5]}```')

        await ctx.send(embed=embed)

async def corona(ctx, txt): 
    if 'Î™®Îì†' in txt or 'Î™®Îëê' in txt or 'ÏûêÏÑ∏Ìûà' in txt: 
        Outputoption = 'all' 
        size = 'ÏûêÏÑ∏Ìïú'

    elif 'Ïò§Îäò' in txt or 'Ìà¨Îç∞Ïù¥' in txt or 'ÏùºÏùº' in txt: 
        Outputoption = 'today' 
        size = 'Ïò§Îäò'

    elif 'Ï†ÑÏ≤¥' in txt or 'ÌÜ†ÌÉà' in txt or 'ÎàÑÏ†Å' in txt: 
        Outputoption = 'total' 
        size = 'ÎàÑÏ†Å'

    else: 
        size = 'Ïò§Îäò/ÎàÑÏ†Å'
        Outputoption = None

    output = option.Crawling().corona(Outputoption)

    embed = nextcord.Embed(title=f'{size} ÏΩîÎ°úÎÇò ÌòÑÌô©', description='```ÏΩîÎ°úÎÇò ÌòÑÌô©ÏûÖÎãàÎã§.```',color=colors['MAIN']) 
    await ctx.send(embed=embed)

    if Outputoption == None: 
        day_embed = nextcord.Embed(title='Ïò§Îäò', color=colors['MAIN']) 
        day_embed.add_field(name='ÏÇ¨ÎßùÏûê', value=f'```{output[1][0]}Î™Ö```')
        day_embed.add_field(name='Ïû¨Ïõê ÏúÑÏ§ëÏ¶ù', value=f'```{output[1][1]}Î™Ö```')
        day_embed.add_field(name='Ïã†Í∑ú ÏûÖÏõê', value=f'```{output[1][2]}Î™Ö```')
        day_embed.add_field(name='ÌôïÏßÑÏûê', value=f'```{output[1][3]}Î™Ö```')
        await ctx.send(embed=day_embed)

        total_embed = nextcord.Embed(title='ÎàÑÏ†Å', color=colors['MAIN']) 
        total_embed.add_field(name='ÏÇ¨ÎßùÏûê', value=f'```{output[0][0]}Î™Ö```')
        total_embed.add_field(name='ÌôïÏßÑÏûê', value=f'```{output[0][1]}Î™Ö```')
        await ctx.send(embed=total_embed)

    elif Outputoption == 'today': 
        #ÏÇ¨Îßù, Ïû¨Ïõê ÏúÑÏ§ëÏ¶ù, Ïã†Í∑ú ÏûÖÏõê, ÌôïÏßÑ 
        day_embed = nextcord.Embed(title='Ïò§Îäò', color=colors['MAIN']) 
        day_embed.add_field(name='ÏÇ¨ÎßùÏûê', value=f'```{output[0][0]} Î™Ö```')
        day_embed.add_field(name='Ïû¨Ïõê ÏúÑÏ§ëÏ¶ù', value=f'```{output[0][1]} Î™Ö```')
        day_embed.add_field(name='Ïã†Í∑ú ÏûÖÏõê', value=f'```{output[0][2]} Î™Ö```')
        day_embed.add_field(name='ÌôïÏßÑÏûê', value=f'```{output[0][3]} Î™Ö```')
        await ctx.send(embed=day_embed)

    elif Outputoption == 'total': 
        total_embed = nextcord.Embed(title='ÎàÑÏ†Å', color=colors['MAIN']) 
        total_embed.add_field(name='ÏÇ¨ÎßùÏûê', value=f'```{output[0][0]} Î™Ö```')
        total_embed.add_field(name='ÌôïÏßÑÏûê', value=f'```{output[0][1]} Î™Ö```')
        await ctx.send(embed=total_embed)

    elif Outputoption == 'all': 
        day_embed = nextcord.Embed(title='Ïò§Îäò', color=colors['MAIN']) 
        day_embed.add_field(name='ÏÇ¨ÎßùÏûê', value=f'```{output[1][0]} Î™Ö```')
        day_embed.add_field(name='Ïû¨Ïõê ÏúÑÏ§ëÏ¶ù', value=f'```{output[1][1]} Î™Ö```')
        day_embed.add_field(name='Ïã†Í∑ú ÏûÖÏõê', value=f'```{output[1][2]} Î™Ö```')
        day_embed.add_field(name='ÌôïÏßÑÏûê', value=f'```{output[1][3]} Î™Ö```')
        await ctx.send(embed=day_embed)

        day7_embed = nextcord.Embed(title='7Ïùº ÌèâÍ∑†', color=colors['MAIN']) 
        day7_embed.add_field(name='ÏÇ¨ÎßùÏûê', value=f'```{output[2][0]} Î™Ö```')
        day7_embed.add_field(name='Ïû¨Ïõê ÏúÑÏ§ëÏ¶ù', value=f'```{output[2][1]} Î™Ö```')
        day7_embed.add_field(name='Ïã†Í∑ú ÏûÖÏõê', value=f'```{output[2][2]} Î™Ö```')
        day7_embed.add_field(name='ÌôïÏßÑÏûê', value=f'```{output[2][3]} Î™Ö```')
        await ctx.send(embed=day7_embed)

        total_embed = nextcord.Embed(title='ÎàÑÏ†Å', color=colors['MAIN']) 
        total_embed.add_field(name='ÏÇ¨ÎßùÏûê', value=f'```{output[0][0]} Î™Ö```')
        total_embed.add_field(name='ÌôïÏßÑÏûê', value=f'```{output[0][1]} Î™Ö```')
        await ctx.send(embed=total_embed)

async def exchange(ctx, txt): 
    moneys = ['Ïóî', 'Ìò∏Ï£ºÎã¨Îü¨', 'Ìò∏Ï£º Îã¨Îü¨', 'ÏúÑÏïà', 'Ïú†Î°ú', 'ÌååÏö¥Îìú', 'Ïï§', 'Îã¨Îü¨'] 
    
    for money in moneys: 
        if money in txt: 
            break

        else: 
            money = 'Îã¨Îü¨'

    exchange = option.Crawling().exchange(money) 

    if exchange != False: 
        embed = nextcord.Embed(title=f'{money}Ïùò ÌôòÏú®', description=f'```{exchange}Ïõê```', color=colors['MAIN'])

    else: 
        embed = nextcord.Embed(title='ÌôòÏú®', description=f'{money}Ïùò ÌôîÌèê Í∞ÄÏπòÎ•º ÌååÏïÖÌï† Ïàò ÏóÜÏäµÎãàÎã§.', color=colors['RED'])

    await ctx.send(embed=embed)
    #url = f'https://search.naver.com/search.naver?where=nexearch&sm=top_hty&fbm=1&ie=utf8&query={money}+ÌôòÏú®'

#Utility function
async def purge_all(ctx, txt): 
    amount = 1000000
    all = True
    cancel = False
    whe = Confirm(ctx.author)

    processOption = '' 

    if await check_pattern(ctx, txt, 'Ï¶âÏãú') == True:
        processOption = 'Ï¶âÏãú'

    embed = nextcord.Embed(title='ÏÇ≠Ï†ú', description=f'Î™®Îì† Î©îÏÑ∏ÏßÄÎ•º {processOption} ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå?', color=colors['MAIN']) 
    msg = await ctx.send(embed=embed, view=whe)

    await whe.wait()
    await msg.delete()

    if whe.value == True:
        if processOption != 'Ï¶âÏãú':
            embed = nextcord.Embed(title='ÏàòÎùΩÎê®', description='5Ï¥à ÌõÑ Ï≤≠ÏÜåÍ∞Ä ÏßÑÌñâÎê©ÎãàÎã§. Ï∑®ÏÜåÎ•º ÏõêÌïòÏãúÎ©¥ `Ï∑®ÏÜå`Î•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî.', color=colors['GREEN'])
            embed.set_footer(text='Ïò§Î•ò Î©îÏÑ∏ÏßÄÍ∞Ä Îú®ÏßÄ ÏïäÎã§Î©¥ Ïã§Ìñâ Ï§ëÏù∏ Îúª ÏûÖÎãàÎã§!')
            notice = await ctx.send(embed=embed)
        
            embed = nextcord.Embed(title='Ïπ¥Ïö¥Ìä∏Îã§Ïö¥', description='5Ï¥à ÌõÑ ÏßÑÌñâÎê®', color=colors['GREEN']) 
            msg = await ctx.send(embed=embed) 

            await asyncio.sleep(1.2)

            def check(message):
                return message.content == "Ï∑®ÏÜå" and message.channel == ctx.channel and message.author == ctx.author

            for x in range(1, 5):
                if 5-x <= 2: 
                    color = colors['RED']

                elif 5-x <= 4: 
                    color = colors['ORANGE']

                try:
                    embed = nextcord.Embed(title='Ïπ¥Ïö¥Ìä∏Îã§Ïö¥', description=f'{5-x}Ï¥à ÌõÑ ÏßÑÌñâÎê®', color=color)
                    await msg.edit(embed=embed)

                    event = await app.wait_for("message", timeout= 1.2, check=check)

                    if event:
                        cancel = True
                        break

                except asyncio.exceptions.TimeoutError:
                    pass
            
            await msg.delete()
            await notice.delete()

        if cancel == False: 
            try: 
                times = int(amount/100) + 1 
                elseValue = amount-(100*times)
                
                await ctx.channel.purge(limit=1) 
                await ctx.channel.purge(limit=elseValue) 

                for x in range(0, int(times)):
                    try:
                        try:
                            await ctx.channel.purge(limit=100)

                        except: 
                            break
                    
                    except: 
                        embed = nextcord.Embed(title='Ïò§Î•ò', description=f'ÏòàÍ∏∞Ïπò Î™ªÌïú Ïò§Î•òÍ∞Ä Î∞úÏÉùÌïòÏòÄÏäµÎãàÎã§.', color=colors['RED'])
                        await ctx.send(embed=embed)
                        break

            except: 
                embed = nextcord.Embed(title='Ïò§Î•ò', description=f'ÏòàÍ∏∞Ïπò Î™ªÌïú Ïò§Î•òÍ∞Ä Î∞úÏÉùÌïòÏòÄÏäµÎãàÎã§.', color=colors['RED'])
                await ctx.send(embed=embed)

            if all == True:
                embed = nextcord.Embed(title='ÏÇ≠Ï†úÎê®', description='Î™®Îì† Î©îÏÑ∏ÏßÄÎ•º ÏÇ≠Ï†úÌñàÏäµÎãàÎã§.', color=colors['GREEN'])
                embed.add_field(name='Ïù¥Î≤§Ìä∏', value='```ÏÇ≠Ï†ú```')
                embed.add_field(name='Í∞úÏàò', value=f'```{amount}```')
                await ctx.send(embed=embed)

        else: 
            embed = nextcord.Embed(title='Í±∞Ï†àÎê®', description=f'Î©îÏÑ∏ÏßÄ ÏÇ≠Ï†úÍ∞Ä Ï∑®ÏÜåÎêòÏóàÏäµÎãàÎã§.', color=colors['RED'])
            await ctx.send(embed=embed)

async def purge(ctx, txt):
    if await check_promiss(ctx) == True:
        if 'Ï≤≠ÏÜå' or 'ÏÇ≠Ï†ú' in txt:
            if 'Í∞ú' in txt: 
                for line in txt.split(): 
                    if 'Í∞ú' in line: 
                        if int(line.index('Í∞ú')) != 0:
                            amount = int(line.split('Í∞ú')[0])+1

            elif await check_pattern(ctx, txt, 'Ï†ÑÏ≤¥') == True:
                amount = 1000000

            else: 
                output = []
                for num in nums: 
                    if num in txt: 
                        index = txt.index(num) 
                        output.append(index)

                    else: 
                        pass

                if output != []:
                    index = min(output) 
                    output = []
                    output.append(txt[index])
                    for x in range(1, len(txt)+1): 
                        if len(txt) > index+x:
                            if txt[index+x] in nums: 
                                output.append(txt[index+1]) 
                            else:
                                break

                        else:
                            break

                    amount = int("".join(output))

                else: 
                    amount = 1

            if amount == 1000000: 
                await purge_all(ctx, txt) 

            else: 
                whe = Confirm(ctx.author)
                processOption = '' 
                cancel = False

                if await check_pattern(ctx, txt, 'Ï¶âÏãú') == True:
                    processOption = 'Ï¶âÏãú'

                embed = nextcord.Embed(title='ÏÇ≠Ï†ú', description=f'Î©îÏÑ∏ÏßÄ `{amount}`Í∞úÎ•º {processOption} ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå?', color=colors['MAIN']) 
                msg = await ctx.send(embed=embed, view=whe)

                await whe.wait()

                await msg.delete()

                if whe.value == True:
                    if processOption != 'Ï¶âÏãú':
                        embed = nextcord.Embed(title='ÏàòÎùΩÎê®', description='5Ï¥à ÌõÑ Ï≤≠ÏÜåÍ∞Ä ÏßÑÌñâÎê©ÎãàÎã§. Ï∑®ÏÜåÎ•º ÏõêÌïòÏãúÎ©¥ Ï∑®ÏÜåÎ•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî.', color=colors['GREEN'])
                        embed.set_footer(text='Ïò§Î•ò Î©îÏÑ∏ÏßÄÍ∞Ä Îú®ÏßÄ ÏïäÎã§Î©¥ Ïã§Ìñâ Ï§ëÏù∏ Îúª ÏûÖÎãàÎã§!')
                        notice = await ctx.send(embed=embed)
                    
                        embed = nextcord.Embed(title='Ïπ¥Ïö¥Ìä∏Îã§Ïö¥', description='5Ï¥à ÌõÑ ÏßÑÌñâÎê®', color=colors['GREEN']) 
                        msg = await ctx.send(embed=embed) 

                        await asyncio.sleep(1.2)

                        def check(message):
                            return message.content == "Ï∑®ÏÜå" and message.channel == ctx.channel and message.author == ctx.author

                        for x in range(1, 5):
                            if 5-x <= 2: 
                                color = colors['RED']

                            elif 5-x <= 4: 
                                color = colors['ORANGE']

                            try:
                                embed = nextcord.Embed(title='Ïπ¥Ïö¥Ìä∏Îã§Ïö¥', description=f'{5-x}Ï¥à ÌõÑ ÏßÑÌñâÎê®', color=color)
                                await msg.edit(embed=embed)

                                event = await app.wait_for("message", timeout=1.2, check=check)

                                if event:
                                    cancel = True
                                    break

                            except asyncio.exceptions.TimeoutError:
                                pass
                        
                        await msg.delete()
                        await notice.delete()   

                    if cancel == False:
                        amount = len(await ctx.channel.history(limit=amount+1).flatten())-1

                        if amount > 100:
                            try: 
                                times = int(amount/100) + 1 
                                elseValue = amount-(100*times)

                                await ctx.channel.purge(limit=1) 
                                await ctx.channel.purge(limit=elseValue) 

                                for x in range(0, int(times)):
                                    try:
                                        try:
                                            await ctx.channel.purge(limit=100)
                                        except: 
                                            break
                                    
                                    except: 
                                        embed = nextcord.Embed(title='Ïò§Î•ò', description=f'ÏòàÍ∏∞Ïπò Î™ªÌïú Ïò§Î•òÍ∞Ä Î∞úÏÉùÌïòÏòÄÏäµÎãàÎã§.', color=colors['GREEN'])
                                        embed.add_field(name='Ïù¥Î≤§Ìä∏', value='```ÏÇ≠Ï†ú```')
                                        embed.add_field(name='Í∞úÏàò', value=f'```{amount}```')
                                        await ctx.send(embed=embed)

                                        break

                            except: 
                                pass

                        elif amount <= 100:
                            await ctx.channel.purge(limit=amount+1) 

                        embed = nextcord.Embed(title='ÏÇ≠Ï†úÎê®', description=f'Î©îÏÑ∏ÏßÄÎ•º ÏÇ≠Ï†úÌñàÏäµÎãàÎã§.', color=colors['GREEN'])
                        embed.add_field(name='Ïù¥Î≤§Ìä∏', value='```ÏÇ≠Ï†ú```')
                        embed.add_field(name='Í∞úÏàò', value=f'```{amount}```')
                        await ctx.send(embed=embed)

                    else:        
                        embed = nextcord.Embed(description='Î©îÏÑ∏ÏßÄ ÏÇ≠Ï†úÎ•º Í±∞Ï†àÌñàÏäµÎãàÎã§.', color=colors['RED']) 
                        await ctx.send(embed=embed)
                else:
                    embed = nextcord.Embed(description='Î©îÏÑ∏ÏßÄ ÏÇ≠Ï†úÎ•º Í±∞Ï†àÌñàÏäµÎãàÎã§.', color=colors['RED']) 
                    await ctx.send(embed=embed)

async def kick(ctx, txt):
    if await check_promiss(ctx) == True:
        for line in txt.split():
            if '<@!' in line: 
                user_id = line.split('<@!')[1].split('>')[0] 
                user = ctx.guild.get_member(int(user_id))
                break
            
            else: 
                user = None

        if user != None: 
            whe = Confirm(ctx.author)
            embed = nextcord.Embed(title='Ï∂îÎ∞©', description=f'{user.mention}ÎãòÏùÑ Ï∂îÎ∞©ÌïòÏãúÍ≤†ÏäµÎãàÍπå?', color=colors['MAIN']) 
            msg = await ctx.send(embed=embed, view=whe)

            await whe.wait()

            if whe.value == True:
                await msg.delete()
                await user.kick()
                embed = nextcord.Embed(title='Ï∂îÎ∞©Îê®', description=f'Ïú†Ï†ÄÎ•º ÏÇ≠Ï†úÌñàÏäµÎãàÎã§.', color=colors['GREEN'])
                embed.add_field(name='Ïù¥Î≤§Ìä∏', value='```Ï∂îÎ∞©```')
                embed.add_field(name='Ïú†Ï†Ä', value=f'```{user}```')
                await ctx.send(embed=embed)

            else:
                await msg.delete()
                embed = nextcord.Embed(description='Ï∂îÎ∞©ÏùÑ Í±∞Ï†àÌñàÏäµÎãàÎã§.', color=colors['RED']) 
                await ctx.send(embed=embed)

async def set_slow_mode_delay(ctx, txt): 
    if await check_promiss(ctx) == True:
        time_scare = ['Ï¥à', 'Î∂Ñ', 'ÏãúÍ∞Ñ']

        if 'ÏÇ≠Ï†ú' in txt or 'ÏóÜÏï†' in txt or 'Í∞ñÎã§Î≤ÑÎ†§' in txt: 
            await del_slow_mode_delay(ctx, txt)

        else:
            sec = None

            for time in time_scare:
                if time in txt: 
                    index = txt.index(time) 

                    for line in txt.split(): 
                        if time in line: 
                            print(line)
                            sec = int(line.split(time)[0]) 

                            if time == 'Ï¥à': 
                                sec = sec * 1

                            elif time == 'Î∂Ñ': 
                                sec = sec * 60

                            elif time == 'ÏãúÍ∞Ñ': 
                                sec = sec * 3600

                            timeset = time

                            print(sec) 
                            break

            if sec == None:
                txt = "".join(txt.split()) 

                expression= [] 
                numIndex = []
                
                for num in nums: 
                    if num in txt: 
                        index = txt.index(num) 
                        numIndex.append(index)

                    else: 
                        pass

                if numIndex != []:
                    index = min(numIndex) 

                    expression.append(txt[index])
                    for x in range(1, len(txt)+1): 
                        if len(txt) > index+x:
                            if txt[index+x] in nums: 
                                expression.append(txt[index+x]) 
                                
                            else:
                                break

                        else:
                            break

                    sec = int("".join(expression)) 
                    timeset = 'Ï¥à'
            
            if timeset == 'Ï¥à': 
                sec_for = sec
            elif timeset == 'Î∂Ñ': 
                sec_for = int(sec/60)
                timeset = 'Î∂Ñ'
            elif timeset == 'ÏãúÍ∞Ñ': 
                sec_for = int(sec/3600)
                timeset = 'ÏãúÍ∞Ñ'

            if int(sec_for) > 21600: 
                sec = 21600
                sec_for = int(21600/3600) 
                timeset = 'ÏãúÍ∞Ñ'

            elif int(sec) > 21600: 
                sec = 21600
                sec_for = int(21600/3600) 
                timeset = 'ÏãúÍ∞Ñ'

            notify = nextcord.Embed(title='Ïä¨Î°úÏö∞ Î™®Îìú ÏÑ§Ï†ï', color=colors['GREEN'])
            notify.add_field(name=f'{timeset}', value=f'```{sec_for}{timeset}```')
            if timeset != 'Ï¥à':
                notify.add_field(name=f'Ï¥à', value=f'```{sec}Ï¥à```')

            await ctx.send(embed=notify)

            if sec > 21600: 
                sec = 21600
                embed = nextcord.Embed(title='ÏïåÎ¶º', description=f'Í∞íÏù¥ ÏµúÎåÄÍ∞íÏù∏ 6ÏãúÍ∞ÑÏùÑ Ï¥àÍ≥ºÌïòÏó¨ Ïä¨Î°úÏö∞ Î™®ÎìúÍ∞Ä 6ÏãúÍ∞ÑÏúºÎ°ú ÌïòÌñ• ÏÑ§Ï†ïÎêòÏóàÏäµÎãàÎã§.', color=colors['ORANGE'])
                await ctx.send(embed=embed)
                
            await ctx.channel.edit(slowmode_delay=sec)

async def del_slow_mode_delay(ctx, txt): 
    if await check_promiss(ctx) == True:
        notify = nextcord.Embed(title='Ïä¨Î°úÏö∞ Î™®Îìú Ï†úÍ±∞', description='Ïä¨Î°úÏö∞ Î™®ÎìúÍ∞Ä Ï†úÍ±∞ÎêòÏóàÏäµÎãàÎã§.',color=colors['RED'])
        await ctx.send(embed=notify)

        await ctx.channel.edit(slowmode_delay=0)

#etc. Funchtion
async def check_time_mornig(ctx, txt): 
    now = datetime.now()
    now = int(now.strftime('%H')) 

    if now < 12:
        inputLayer = ('ÎåÄÎãµ_ÌèâÎ≤î_ÏïÑÏπ®Ïù∏ÏÇ¨', 'MORNING')

    else: 
        inputLayer = ('ÎåÄÎãµ_Ïù¥ÏÉÅÌïú_ÏïÑÏπ®Ïù∏ÏÇ¨', 'MORNING')

    response = await get_response(inputLayer)
    await ctx.send(response)

async def check_time_night(ctx, txt): 
    now = datetime.now()
    now = int(now.strftime('%H')) 
    if now >= 21:
        inputLayer = ('ÎåÄÎãµ_ÌèâÎ≤î_Ï†ÄÎÖÅÏù∏ÏÇ¨', 'NIGHT')

    else: 
        inputLayer = ('ÎåÄÎãµ_Ïù¥ÏÉÅÌïú_Ï†ÄÎÖÅÏù∏ÏÇ¨', 'NIGHT')

    response = await get_response(inputLayer)
    await ctx.send(response)

async def check_time(ctx, txt): 
    now = datetime.now()
    now = int(now.strftime('%H'))

    #morning 
    if now >= 17: 
        return 'night' 

    elif now >= 12 and now < 16: 
        return 'lunch'

    elif now >= 8 and now <= 11:  
        return 'morning'

async def repeat(ctx, txt): 
    words = ['Îî∞ÎùºÌï¥', 'Ïù¥ÎùºÍ≥† Ìï¥Î¥ê', 'ÎùºÍ≥† Ìï¥Î¥ê']

    for word in words: 
        if word in txt: 
            table = txt.split(word)  
            if table[0] == '': 
                sentence = table[1]

            elif table[1] == '': 
                sentence = table[0] 

            else: 
                sentence = 'Î≠ò Îî∞ÎùºÌï¥Ïïº ÌïòÎäîÍ±¥Í∞ÄÏöî?'

            break


    await ctx.send(sentence)

async def count_line(ctx, txt): 
    lines = 0  

    files = ['main', 'option', 'module']
    for file in files:
        for line in open(f"{file}.py"):  
            lines += 1     

    return lines

async def check_learn_file(ctx, txt): 
    with open('data.json', 'r', encoding="UTF-8") as f:
        data_intents = json.load(f) 
    file_size = Path('/mnt/c/Users/ychje/Desktop/WORKSPACE/DISCORD/data.json').stat().st_size

    embed = nextcord.Embed(title='ÌïôÏäµ Îç∞Ïù¥ÌÑ∞ ÌòÑÌô©', description='ÌïôÏäµ Îç∞Ïù¥ÌÑ∞Îäî Îã§ÏùåÍ≥º Í∞ôÏäµÎãàÎã§.') 
    embed.add_field(name='intents', value=f'```{len(data_intents)}Í∞ú```')
    embed.add_field(name='mappings', value=f'```{len(mappings)}Í∞ú```')
    embed.add_field(name='code', value=f'```{await count_line(ctx, txt)}Ï§Ñ```', inline=False)
    embed.add_field(name='file size', value=f'```{round(file_size/1024, 1)}KB```')
    await ctx.send(embed=embed)

async def find_word(ctx, txt):
    index = 0 
    
    if "\"" in txt or "\'" in txt: 
        try:
            word = txt.split('\"') 

        except:
            word = txt.split('\'') 

        for letter in word: 
            if letter != "": 
                word = letter
                break

    else:
        for line in txt.split(): 
            if 'Îúª' == line[0] or 'Îúª' == line[-1] or 'ÏïåÎ†§Ï§ò' in line: 
                break

            else: 
                index += 1 

        if 'Îúª' == txt.split()[index-1]: 
            word == txt.split()[index-2] 

        else: 
            word = txt.split()[index-1]

    results = option.Crawling().find_word(word) 

    if results != False: 
        definitions = '' 
        
        for x in range(1, len(results)): 
            definitions += f'{x}. {results[x]}\n' 

        embed = nextcord.Embed(title=f'{word} : ', description=f'```{results[0]}```', color=colors['MAIN'])
        if len(results) > 1:
            embed.add_field(name='Îòê Îã§Î•∏ Îúª', value=f'```{definitions}```')
            embed.set_footer(text='ÏÇ¨Ïö©ÏûêÎãòÏù¥ ÏÉùÍ∞ÅÌïòÎçò Îã®Ïñ¥Í∞Ä ÏïÑÎãàÎùºÎ©¥ \" \" (Îî∞Ïò¥Ìëú) ÏïàÏóê ÎÑ£Ïñ¥ÏÑú ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.')
        await ctx.send(embed=embed) 

    else:
        embed = nextcord.Embed(title='Í≤ÄÏÉâ Ïã§Ìå®', description=f'```Î®ºÎç∞Ïù¥Í∞Ä {word}Ïóê ÎåÄÌïú Í≤∞Í≥ºÎ•º Ï∞æÏßÄ Î™ª ÌñàÏäµÎãàÎã§.', color=colors['RED'])
        embed.set_footer(text='ÏÇ¨Ïö©ÏûêÎãòÏù¥ ÏÉùÍ∞ÅÌïòÎçò Îã®Ïñ¥Í∞Ä ÏïÑÎãàÎùºÎ©¥ \" \" (Îî∞Ïò¥Ìëú) ÏïàÏóê ÎÑ£Ïñ¥ÏÑú ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.')
        await ctx.send(embed=embed)  

async def check_word(ctx, txt):
    index = 0 
    
    if "\"" in txt or "\'" in txt: 
        try:
            word = txt.split('\"') 

        except:
            word = txt.split('\'') 

        for letter in word: 
            if letter != "": 
                result = letter
                break

    else:
        index = 0 
        find_stat = False
        result = None


        for line in txt.split(): 
            words = ['Ïù¥', 'Í∞Ä', 'Ïù¥Í∞Ä', 'ÎùºÎäî', 'Ïù¥ÎùºÎäî', 'ÎûÄ']
            
            for word in words: 
                if word in line:  
                    if line.split(word)[0] == '': 
                        line.split(word)[0]
                        result = txt.split()[index-1]

                    elif line.split(word)[0] != '': 
                        result = line.split(word)[0] 

                    if result != None: 
                        results = option.Crawling().find_word(result, 'Ï°¥Ïû¨Ïú†Î¨¥')

                        if results == True: 
                            break

            index += 1

    if result != None: 
        results = option.Crawling().find_word(result, 'Ï°¥Ïû¨Ïú†Î¨¥')

        if results == True: 
            inputLayer = ('ÎåÄÎãµ_Îã®Ïñ¥_Ï°¥Ïû¨Ïú†', 'True')

        elif results == False: 
            inputLayer = ('ÎåÄÎãµ_Îã®Ïñ¥_Ï°¥Ïû¨Î¨¥', 'False')

        response = await get_response(inputLayer)
        
        await ctx.send(f'Ìù†.. {result}.. {response}')

    else: 
        await ctx.send('Ïñ¥Îñ§ Îã®Ïñ¥Î•º ÎßêÏîÄÌïòÏãúÎäîÏßÄ Î™®Î•¥Í≤†Ïñ¥Ïöî \" \" ÏÇ¨Ïù¥Ïóê ÎÑ£Ïñ¥ÏÑú Î∞îÎ°ú Ïù¥Ìï¥Ìï† Ïàò ÏûàÍ≤å Ìï¥Ï£ºÏÑ∏Ïöî.')

async def cal_time(ctx, txt): 
    timescare = ['Ïãú', 'ÏãúÍ∞Ñ', 'Î∂Ñ', 'Ï¥à', 'Ï†Ñ', 'ÌõÑ', 'Îí§'] 

    time_expression = ''
    index = 0 

    for scare in timescare: 
        for line in txt.split():
            if scare in line: 

                time = line.split(scare)[0] if line.split(scare)[0] != '' else line.split(scare)[1] 
                
                if time_expression != '': 
                    if scare == 'Ï†Ñ': 
                        time_expression += '#-'
                        
                    elif scare == 'ÌõÑ' or scare == 'Îí§': 
                        time_expression += '#+' 

                if scare == 'Ïãú' or scare == 'ÏãúÍ∞Ñ':
                    if 'h' in time_expression and '/' not in time_expression: 
                        time_expression += f'/{time}h'                
                    
                    else: 
                        time_expression += f'{time}h' 

                elif scare == 'Î∂Ñ':
                    if 'm' in time_expression and '/' not in time_expression: 
                        time_expression += f'/{time}m'

                    else: 
                        time_expression += f'{time}m'

                elif scare == 'Ï¥à':
                    if 's' in time_expression and '/' not in time_expression: 
                        time_expression += f'/{time}s' 

                    else: 
                        time_expression += f'{time}s'

            #if index != 0 and time_expression != '' or time_expression == 1: 
            #    index += 1

    timeValue = [0, 0] 
    index = 0 
    print(time_expression) 

    expressions = time_expression.split('#')[0].split('/') 
    signs = time_expression.split('#')[1:]

    print(expressions)
    print(signs)

    for expression in expressions: 
        if 'h' in expression: 
            print('h', expression)
            timeValue[index] += int(expression.split('h')[0])*3600
            expression = expression.split('h')[1]
            print('fh', expression)

        if 'm' in expression: 
            print('m', expression)
            timeValue[index] += int(expression.split('m')[0])*60
            expression = expression.split('m')[1] 
            print('fm', expression)

        if 's' in expression: 
            print('s', expression)
            timeValue[index] += int(expression.split('s')[1]) 
            print('fs', expression)
            continue

        index += 1

    print(timeValue) 
    print(timeValue[0]) 
    print(timeValue[1])
       
async def reminder(ctx, txt): 
    timescares = ['Ïãú', 'ÏãúÍ∞Ñ', 'Î∂Ñ', 'Ï¥à'] 

    time_expression = ''

    for timescare in timescares: 
        if timescare in txt: 

            for line in txt.split():
                if timescare in line: 

                    time = line.split(timescare)[0] if line.split(timescare)[0] != '' else line.split(timescare)[1] 
                    
                    if time_expression != '': 
                        if timescare == 'Ï†Ñ': 
                            time_expression += '#-'
                            
                        elif timescare == 'ÌõÑ' or timescare == 'Îí§': 
                            time_expression += '#+' 

                    if timescare == 'Ïãú' or timescare == 'ÏãúÍ∞Ñ':
                        if 'h' in time_expression and '/' not in time_expression: 
                            time_expression += f'/{time}h'                
                        
                        else: 
                            time_expression += f'{time}h' 

                    elif timescare == 'Î∂Ñ':
                        if 'm' in time_expression and '/' not in time_expression: 
                            time_expression += f'/{time}m'

                        else: 
                            time_expression += f'{time}m'

                    elif timescare == 'Ï¥à':
                        if 's' in time_expression and '/' not in time_expression: 
                            time_expression += f'/{time}s' 

                        else: 
                            time_expression += f'{time}s'
    
    scares = ['h', 'm', 's'] 

    time = []
    time_set = ""
    for scare in scares:
        if scare in time_expression:
            time.append(int(time_expression.split(scare)[0]))
            time_expression = time_expression.split(scare)[1]

            if scare == 'h': 
                if time_set != '':
                    time_set += f' {time[0]}ÏãúÍ∞Ñ'
                
                else: 
                    time_set += f'{time[0]}ÏãúÍ∞Ñ'

            elif scare == 'm':
                if time_set != '':
                    time_set += f' {time[1]}Î∂Ñ'
                
                else: 
                    time_set += f'{time[1]}Î∂Ñ'

            elif scare == 's':
                if time_set != '':
                    time_set += f' {time[2]}Ï¥à'
                
                else: 
                    time_set += f'{time[2]}Ï¥à'

        else: 
            time.append(0) 

    hour = 0 if time[0] == 0 else time[0] 
    minute = 0 if time[1] == 0 else time[1] 
    second = 0 if time[2] == 0 else time[2] 

    embed = nextcord.Embed(title='ÏïåÎûå ÏÑ§Ï†ï', description=f'{ctx.author.mention}Îãò! `{time_set} ÌõÑ`Ïóê ÏïåÎ†§ÎìúÎ¶¥Í≤åÏöî!', color=colors['MAIN'])
    embed.add_field(name='ÏïåÎûå ÏÑ§Ï†ï ÏãúÍ∞Ñ', value=f'```{time_set} ÌõÑ```')
    reminder = await ctx.send(embed=embed) 

    await asyncio.sleep(hour*3600+minute*60+second) 

    await reminder.delete()

    embed = nextcord.Embed(title=f'{ctx.author.name}ÎãòÏùò ÏïåÎûå', description=f'{ctx.author.mention}Îãò! ÎßêÏîÄÌïòÏã† `{time_set}`Ïù¥ ÏßÄÎÇ¨ÏäµÎãàÎã§.' if time_set[-1] != 'Ï¥à' else f'{ctx.author.mention}Îãò! ÎßêÏîÄÌïòÏã† `{time_set}`Í∞Ä ÏßÄÎÇ¨ÏäµÎãàÎã§.', color=colors['GREEN'])
    await ctx.send(embed=embed)

#Notification when the bot has been activated
@app.event
async def on_ready():
    #await app.change_presence(status=nextcord.Status.online)
    #await app.change_presence(status=nextcord.Game(name="Í≤åÏûÑ ÌïòÎäîÏ§ë"))
    #await app.change_presence(status=nextcord.Streaming(name="Ïä§Ìä∏Î¶º Î∞©ÏÜ°Ï§ë", url='ÎßÅÌÅ¨'))
    #await app.change_presence(status=nextcord.Activity(type=nextcord.ActivityType.listening, name="ÎÖ∏Îûò Îì£ÎäîÏ§ë"))
    await app.change_presence(status=nextcord.Activity(type=nextcord.ActivityType.watching, name="ÏòÅÏÉÅ ÏãúÏ≤≠Ï§ë"))
    print(f'[*] Connected with {app.user}')

@app.command()
async def userinfo(ctx, *, user: nextcord.Member = None):
    if user is None:
        user = ctx.author   
    """
    print(type(ctx.author))
    date_format = "%Y-%m-%d(%a) %I:%M %p"
    embed = nextcord.Embed(color=0xdfa3ff, description=user.mention)
    embed.set_author(name=str(user), icon_url=user.avatar)
    embed.set_thumbnail(url=user.avatar)
    embed.add_field(name="Í∏∏Îìú Í∞ÄÏûÖÏùº", value=f'```{user.joined_at.strftime(date_format)}```', inline=False)
    members = sorted(ctx.guild.members, key=lambda m: m.joined_at)
    embed.add_field(name="Join position", value=f'```{str(members.index(user)+1)}```', inline=False)
    embed.add_field(name="Í≥ÑÏ†ï ÏÉùÏÑ±Ïùº", value=f'```{user.created_at.strftime(date_format)}```', inline=False)
    if len(user.roles) > 1:
        role_string = ' '.join([r.mention for r in user.roles][1:])
        embed.add_field(name=f"Ïó≠Ìï† [{len(user.roles)-1}Í∞ú]", value=role_string, inline=False)
    perm_string = '\n'.join([str(p[0]).replace("_", " ").title() for p in user.guild_permissions if p[1]])
    embed.add_field(name="Í∏∏Îìú Í∂åÌïú", value=f'```{perm_string}```', inline=False)
    embed.set_footer(text='ID: ' + str(user.id))
    return await ctx.send(embed=embed)"""
    await get_user_info(ctx, ctx.message.content, user)

@app.command()
async def serverinfo(ctx, guild:nextcord.Guild=None):

    if guild == None: 
        guild = ctx.guild

    await get_guild_info(ctx, ctx.message.content, guild)

async def get_user_info(ctx, txt, user): 
    date_format = "%Y-%m-%d %H:%M:%S"

    if str(user.status) == 'online': 
        status = 'üü¢'

    elif str(user.status) == 'offline':
        status = '‚ö´'

    elif str(user.status) == 'dnd' or user.status == 'do_not_disturb': 
        status = 'üî¥'

    elif str(user.status) == 'idle': 
        status = 'üü°'

    elif str(user.status) == 'invisible': 
        status = 'Ïò§ÌîÑÎùºÏù∏ÏúºÎ°ú ÌëúÏãú'
        print(user.status)

    else: 
        status = ''

    connectStatus = ''

    if str(user.desktop_status) != 'offline':
        connectStatus = 'Îç∞Ïä§ÌÅ¨ÌÉë'

    if str(user.web_status) != 'offline':
        if connectStatus != '':
            connectStatus += ', Ïõπ'

        else: 
            connectStatus = 'Ïõπ'

    if str(user.mobile_status) != 'offline':
        if connectStatus != '':
            connectStatus += ', Î™®Î∞îÏùº(Ìú¥ÎåÄÌè∞)'

        else: 
            connectStatus = 'Î™®Î∞îÏùº(Ìú¥ÎåÄÌè∞)'

    if connectStatus == '':
        connectStatus = 'ÎØ∏Ï†ëÏÜç'
    
    if status == '' and connectStatus != 'ÎØ∏Ï†ëÏÜç':
        status = 'ÎØ∏ÌôïÏù∏'

    activity = ''

    try:
        if str(user.activity.type) == 'Spotify':
            title = user.activity.title
            
            if len(user.activity.artists) > 1: 
                artists = "".join(user.activity.artists)

            else: 
                artists = user.activity.artist

            activity = f'SpotifyÏóêÏÑú {title} - {artists} Îì£Îäî Ï§ë'

        elif str(user.activity.type) == 'ActivityType.playing': 
            application = user.activity.name 

            activity = f'{application} ÌïòÎäî Ï§ë'

        elif str(user.activity.type) == 'ActivityType.streaming': 
            name = user.activity.name 

            print(user.activity)
            activity = f'{name} Î∞©ÏÜ° Ï§ë'

        elif str(user.activity.type) == 'ActivityType.custom':
            print(user.activity) 
            activity = user.activity

        else: 
            if activity == '':
                activity = 'ÏóÜÏùå'

    except:
        if activity == '': 
            activity = 'ÏóÜÏùå' 

    embed = nextcord.Embed(title=f'{user}ÎãòÏùò Ï†ïÎ≥¥' if user.bot != True else f'**{user}**Î¥áÏùò Ï†ïÎ≥¥', color=colors['MAIN'])
    embed.set_author(name=f'{user}', icon_url=user.avatar if user.avatar != None else user.display_avatar) 
    embed.set_thumbnail(url=user.display_avatar)
    embed.add_field(name='Ïú†Ï†Ä', value=f'```{user.name}```')
    embed.add_field(name='Î≥ÑÎ™Ö', value=f'```{user.display_name}```')
    embed.add_field(name='ÏÉÅÌÉú', value=f'```{status}```')
    embed.add_field(name='Ï†ëÏÜç ÌîåÎû´Ìèº', value=f'```{connectStatus}```')
    embed.add_field(name='ÌôúÎèô', value=f'```{activity}```', inline=False)
    embed.add_field(name="Í≥ÑÏ†ï ÏÉùÏÑ±Ïùº", value=f'```{user.created_at.strftime(date_format)}```')
    members = sorted(ctx.guild.members, key=lambda m: m.joined_at)
    joinPosition = str(members.index(user)+1)
    embed.add_field(name=f'Í∏∏Îìú Í∞ÄÏûÖÏùº ({ctx.guild.member_count}Î™Ö Ï§ë {joinPosition}Î≤àÏß∏ Ïú†Ï†Ä)', value=f'```{user.joined_at.strftime(date_format)}```', inline=True) 
    if len(user.roles) > 1:
        role_string = '\n'.join([r.mention for r in user.roles][1:])
        embed.add_field(name=f"Ïó≠Ìï† ({len(user.roles)-1}Í∞ú)", value=f'{role_string}', inline=False)
    else: 
        embed.add_field(name=f"Ïó≠Ìï†", value='```Î∂ÄÏó¨Î∞õÏùÄ Ïó≠Ìï†Ïù¥ ÏóÜÏäµÎãàÎã§.```', inline=False)
    await ctx.send(embed=embed)

async def get_guild_info(ctx, txt, guild): 
    date_format = "%Y-%m-%d %H:%M:%S"

    if guild.rules_channel != None and guild.public_updates_channel != None: 
        guild_community = True
    else:
        guild_community = False

    embed = nextcord.Embed(title=f'{guild} Ï†ïÎ≥¥', color=colors['MAIN'])
    embed.set_thumbnail(url=guild.icon)
    print(guild.max_members)
    print(guild.max_presences) 
    print(guild.verification_level)
    print(guild.features)

    embed.add_field(name='ÏÑúÎ≤Ñ', value=f'```{guild.name}```') 
    embed.add_field(name='ÏßÄÏó≠', value=f'```{guild.region}```', inline=True)
    embed.add_field(name='Ïò§ÎÑà', value=f'```{guild.owner}```', inline=True)
    embed.add_field(name='ÏÑúÎ≤Ñ ÏÉùÏÑ±Ïùº', value=f'```{guild.created_at.strftime(date_format)}```', inline=False)
    embed.add_field(name='Ï¥ù Ïú†Ï†Ä', value=f'```{len(guild.members)}Î™Ö```', inline=True)
    embed.add_field(name='Ïú†Ï†Ä', value=f'```{len(guild.humans)}Î™Ö```', inline=True)
    embed.add_field(name='Î¥á', value=f'```{len(guild.bots)}Í∞ú```', inline=True)
    embed.add_field(name='Î∂ÄÏä§Ìä∏ Î†àÎ≤®', value=f'```{guild.premium_tier}Î†àÎ≤®```', inline=True)
    embed.add_field(name='Î∂ÄÏä§Ìä∏ ÌöüÏàò', value=f'```{guild.premium_subscription_count}Ìöå```', inline=True)
    embed.add_field(name='Î∂ÄÏä§ÌÑ∞', value=f'```{len(guild.premium_subscribers)}Î™Ö```', inline=True)
    embed.add_field(name='Ïª§ÎÆ§ÎãàÌã∞', value=f'```ÌôúÏÑ±Ìôî```' if guild_community == True else '```ÎπÑÌôúÏÑ±Ìôî```', inline=True)
    embed.add_field(name='Í∑úÏπô Ï±ÑÎÑê', value=f'{guild.rules_channel.mention}' if guild.rules_channel != None else '```ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏùå```', inline=True)
    embed.add_field(name='Í≥µÏßÄ Ï±ÑÎÑê', value=f'{guild.public_updates_channel.mention}' if guild.public_updates_channel != None else '```ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏùå```', inline=True)
    embed.add_field(name='ÏãúÏä§ÌÖú Ï±ÑÎÑê', value=f'{guild.system_channel.mention}' if guild.system_channel != None else '```ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏùå```', inline=True)
    embed.add_field(name='Ïû†Ïàò Ï±ÑÎÑê', value=f'{guild.afk_channel.mention}' if guild.afk_channel != None else '```ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏùå```')
    embed.add_field(name='Ïû†Ïàò Í∞ÑÏ£º ÏãúÍ∞Ñ', value=f'```{int(int(guild.afk_timeout)/60)}Î∂Ñ```') 
    embed.add_field(name='Î™®Îì† Ï±ÑÎÑê', value=f'```{len(guild.channels)}Í∞ú```', inline=False)
    embed.add_field(name='Ïπ¥ÌÖåÍ≥†Î¶¨', value=f'```{len(guild.categories)}Í∞ú```', inline=False)
    embed.add_field(name='Ï±ÑÌåÖ Ï±ÑÎÑê', value=f'```{len(guild.text_channels)}Í∞ú```', inline=True)
    embed.add_field(name='Ïä§ÌÖåÏù¥ÏßÄ Ï±ÑÎÑê', value=f'```{len(guild.stage_channels)}Í∞ú```', inline=True)
    embed.add_field(name='Î≥¥Ïù¥Ïä§ Ï±ÑÎÑê', value=f'```{len(guild.voice_channels)}Í∞ú```', inline=True)
    embed.add_field(name='Ïó≠Ìï†', value=f'```{len(guild.roles)}Í∞ú```', inline=True)
    embed.add_field(name='Ïù¥Î™®ÏßÄ', value=f'```{len(guild.emojis)}Í∞ú```', inline=True)
    embed.add_field(name='Ïä§Ìã∞Ïª§', value=f'```{len(guild.stickers)}Í∞ú```', inline=True)

    if guild.banner != None: 
        embed.set_image(url=guild.banner)
    await ctx.send(embed=embed) 

async def check_time_site(ctx, txt): 
    sitePointers = ['https', 'http', 'www'] 

    for sitePointer in sitePointers: 
        if sitePointer in sitePointers: 
            break

    index = txt.find(sitePointer)

    site = ''

    for x in range(index, len(txt)):
        if txt[x] != ' ': 
            site += f'{txt[x]}'

        elif txt[x] != '': 
            site += f'{txt[x]}'


    #ÌååÏù∏ÎìúÎ°ú Î∞îÍæ∏Í≥† Ïó¨Í∏∞ÏÑú ÎÇòÏò® Ïù∏Îç±Ïä§ Í∞íÏùÑ ÏãúÏûëÏúºÎ°ú ÎùÑÏó¨Ïì∞Í∏∞ ÎÇòÏò¨ ÎåÄÍπåÏßÄ ÏÇ¨Ïù¥Ìä∏ Ï£ºÏÜåÎ°ú Í∞ÑÏ£º
    #Ïó¨Î∞±Ïù¥ ÎÇòÏò§Î©¥ ÏÇ¨Ïù¥Ìä∏ ÎÅù Í∞ÑÏ£º

    time = option.Crawling().check_time_site(site)  

    embed = nextcord.Embed(title=f'[ÏÇ¨Ïù¥Ìä∏](<{site}>) ÏÑúÎ≤ÑÏãúÍ∞Ñ', color=colors['MAIN'])
    embed.add_field(name='ÏÇ¨Ïù¥Ìä∏', value=f'```{site}```')
    embed.add_field(name='ÏÑúÎ≤ÑÏãúÍ∞Ñ', value=f'{time}')
    clock = await ctx.send(embed=embed)

    await asyncio.sleep(1) 

    for x in range(0, 60*5):
        embed = nextcord.Embed(title=f'ÏÑúÎ≤ÑÏãúÍ∞Ñ', description=f'[ÏÇ¨Ïù¥Ìä∏]'+site ,color=colors['MAIN'])
        sec = int(time.split('Î∂Ñ')[1].split('Ï¥à')[0]) + 1 
        timeStamp = time.split('Î∂Ñ')[0]
        
        if sec == 60: 
            min = int(time.split('Ïãú')[1].split('Î∂Ñ')[0]) + 1
            timeStamp = f"{time.split('Ïãú')[1]}Ïãú {min}Î∂Ñ"
            sec = 0 

        time = f'{timeStamp}Î∂Ñ {sec}Ï¥à'

        embed.add_field(name='ÏÑúÎ≤ÑÏãúÍ∞Ñ', value=f'{time}', inline=False)
        await asyncio.sleep(1) 
        await clock.edit(embed=embed)

#Func for some has script
mappings = {"Î©îÏÑ∏ÏßÄÏ≤≠ÏÜå":'purge',
            "Î©îÏÑ∏ÏßÄÏ≤≠ÏÜå_Î™®Îëê":'purge',
            "Ï∂îÎ∞©":'kick', 
            "ÏïÑÏπ®Ïù∏ÏÇ¨":'check_time_mornig',
            "Ï†ÄÎÖÅÏù∏ÏÇ¨":'check_time_night', 
            "ÏßàÎ¨∏_Ìïë":'check_ping', 
            "ÏÉÅÌÉú":'stats',
            "Í≥ÑÏÇ∞":'cal', 
            "Î≤àÏó≠":'translate', 
            "ÎÇ†Ïî®":'weather',
            "ÏΩîÎ°úÎÇò":'corona', 
            "ÌôòÏú®":'exchange', 
            "Îî∞ÎùºÌïòÍ∏∞":'repeat', 
            "Ïä¨Î°úÏö∞Îã§Ïö¥Î™®ÎìúÏÑ§Ï†ï":'set_slow_mode_delay',
            "Ïä¨Î°úÏö∞Îã§Ïö¥Î™®ÎìúÏÑ§Ï†ï_Ï†úÍ±∞":'del_slow_mode_delay', 
            "ÌïôÏäµÌòÑÌô©ÌôïÏù∏":'check_learn_file', 
            "ÏßàÎ¨∏_Îã®Ïñ¥_Îúª":'find_word', 
            "ÏßàÎ¨∏_Îã®Ïñ¥_Ï°¥Ïû¨Ïú†Î¨¥":'check_word', 
            "ÏãúÍ∞ÑÍ≥ÑÏÇ∞":'cal_time', 
            "Î¶¨ÎßàÏù∏Îçî":'reminder', 
            "ÏÇ¨Ïù¥Ìä∏ÏãúÍ∞Ñ":'check_time_site'}

#@app.command()
#async def ÌÖåÏä§Ìä∏(ctx): 
    #view = Pet() 
    #msg = await ctx.send('ÌÖåÏä§Ìä∏', view=view)

    #await view.wait()

    #await msg.edit(view=None)

@app.command()
async def Î°úÍ∑∏ÏÑ§Ï†ï(ctx):
    if ctx.author.guild_permissions.administrator == True:
        settings = "" 

        for option in options: 
            if guilds[str(ctx.guild.id)]['LOG_OPTION'][options.index(option)] == True: 
                state = 'ON'

            else: 
                state = 'OFF'

            settings += f"**{option}** Ïãú Î°úÍπÖ : `{state}`\n"

        embed = nextcord.Embed(title='Î°úÍ∑∏ ÏÑ§Ï†ï', description=settings, color=colors['MAIN'])
        await ctx.send(embed=embed, view=DropdownView(str(ctx.guild.id)))

@app.command()
async def ÏÖãÏóÖ(ctx): 
    if ctx.author.guild_permissions.administrator == True:
        with open('guild.json', 'r', encoding="UTF-8") as g:
            data_guild = json.load(g)
            a = data_guild

        guild = str(ctx.guild.id)

        if guild not in data_guild:
            view = Confirm(ctx.author) 

            embed = nextcord.Embed(title='ÏãúÏä§ÌÖú Îã§Ïö¥Î°úÎìú', description='ÏãúÏä§ÌÖúÏùÑ Îã§Ïö¥Î°úÎìúÌïòÏãúÍ≤†ÏäµÎãàÍπå?', color=colors['MAIN']) 
            msg = await ctx.send(embed=embed, view=view)

            await view.wait()

            await msg.delete()

            if view.value == True: 
                guilds[str(guild)] = 0
                update_guild()

                embed = nextcord.Embed(description=f'```ÏãúÏä§ÌÖú Îã§Ïö¥Î°úÎìúÎêòÏóàÏäµÎãàÎã§.```', color=colors['GREEN'])
                await ctx.send(embed=embed)

            else:
                embed = nextcord.Embed(description=f'```ÏãúÏä§ÌÖú ÏÖãÏóÖÏù¥ Ï∑®ÏÜåÎêòÏóàÏäµÎãàÎã§.```', color=colors['RED'])
                await ctx.send(embed=embed)

        else: 
                embed = nextcord.Embed(description=f'```Ïù¥ÎØ∏ ÏãúÏä§ÌÖúÏù¥ Îã§Ïö¥Î°úÎìúÎêòÏñ¥ ÏûàÏäµÎãàÎã§.```', color=colors['RED'])
                await ctx.send(embed=embed)

@app.command()
async def Î°úÍ∑∏ÏÖãÏóÖ(ctx):  
    if ctx.author.guild_permissions.administrator == True:
        with open('guild.json', 'r', encoding="UTF-8") as g:
            data_guild = json.load(g)

        guild = str(ctx.guild.id)

        if guild in data_guild:
            if get(ctx.guild.categories, name='MONDAY').name != 'MONDAY':
                view = Confirm(ctx.author)

                embed = nextcord.Embed(title='Î°úÍ∑∏ ÌôúÏÑ±Ìôî', description='Î°úÍ∑∏Î•º ÌôúÏÑ±ÌôîÌïòÏãúÍ≤†ÏäµÎãàÍπå?', color=colors['MAIN']) 
                msg = await ctx.send(embed=embed, view=view)

                await view.wait()

                await msg.delete()
                
                if view.value == True: 
                    category = await ctx.guild.create_category("MONDAY")
                    await ctx.guild.create_text_channel(name='Î°úÍ∑∏', category=category)
                    channel = get(ctx.guild.channels, name="Î°úÍ∑∏")

                    #guilds[guild]['join']['message']
                    #join left message_delete message_edit channel_create channel_delete user_role_change user_nick_change role_create role_delete guild_role_name_change guild_role_color_change user_ban user_unban create_invite delete_invite
                    LOG_OPTION = [True for i in range(len(options))]
                    LOG_OPTION[0] = False
                    guilds[guild] = {'LOG':channel.id, 'LOG_OPTION':LOG_OPTION, 'CATEGORY':category.id, 'JOIN':{'CHANNEL':None, 'MESSAGE':'{user.mention}ÎãòÏù¥ ÏÑúÎ≤ÑÏóê ÏûÖÏû•ÌïòÏÖ®ÏäµÎãàÎã§. (Í∏∞Î≥∏Í∞í)'}, 'EXIT':{'CHANNEL':None, 'MESSAGE':'{user}ÎãòÏù¥ ÏÑúÎ≤ÑÏóê Îñ†ÎÇòÏÖ®ÏäµÎãàÎã§. (Í∏∞Î≥∏Í∞í)'}} 
                    update_guild()

                    embed = nextcord.Embed(description=f'```Î°úÍ∑∏ ÏÑ§Ï†ïÏù¥ ÏôÑÎ£åÎêòÏóàÏäµÎãàÎã§.```', color=colors['GREEN'])
                    await ctx.send(embed=embed)

                else: 
                        embed = nextcord.Embed(description=f'```Î°úÍ∑∏ ÏÑ§Ï†ïÏùÑ Ï∑®ÏÜåÌñàÏäµÎãàÎã§.```', color=colors['RED'])
                        await ctx.send(embed=embed)

            else: 
                embed = nextcord.Embed(description=f'```Ïù¥ÎØ∏ Î°úÍ∑∏ ÏÑ§Ï†ïÏù¥ ÏôÑÎ£åÎêòÏñ¥ ÏûàÏäµÎãàÎã§.```', color=colors['RED'])
                await ctx.send(embed=embed)

        else: 
                embed = nextcord.Embed(description=f'```ÏãúÏä§ÌÖúÏù¥ Îã§Ïö¥Î°úÎìúÎêòÏñ¥ÏûàÏßÄ ÏïäÏäµÎãàÎã§.```', color=colors['RED'])
                await ctx.send(embed=embed)

@app.command()
async def ÏÇ≠Ï†ú(ctx): 
    if ctx.author.guild_permissions.administrator == True:
        with open('guild.json', 'r', encoding="UTF-8") as g:
            data_guild = json.load(g)

        guild = str(ctx.guild.id)

        if guild in data_guild:

            if get(ctx.guild.categories, name='MONDAY') != None:
                
                view = Confirm(ctx.author) 

                embed = nextcord.Embed(title='Î®ºÎç∞Ïù¥ ÏÇ≠Ï†ú', description='Î®ºÎç∞Ïù¥ ÏãúÏä§ÌÖúÏùÑ ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå?', color=colors['MAIN']) 
                msg = await ctx.send(embed=embed, view=view)

                await view.wait()

                await msg.delete()

                if view.value == True:
                    category = get(ctx.guild.categories, name='MONDAY')


                    for channel in category.text_channels:
                        await channel.delete()
                    await category.delete()

                    del guilds[guild] 
                    update_guild()

                    embed = nextcord.Embed(description=f'```ÏãúÏä§ÌÖúÏù¥ ÏÇ≠Ï†úÎêòÏóàÏäµÎãàÎã§.```', color=colors['GREEN'])
                    await ctx.send(embed=embed)
                else: 
                    embed = nextcord.Embed(description=f'```ÏãúÏä§ÌÖúÏù¥ ÏÇ≠Ï†úÍ∞Ä Ï∑®ÏÜåÎêòÏóàÏäµÎãàÎã§.```', color=colors['RED'])
                    await ctx.send(embed=embed)


        else:
            embed = nextcord.Embed(description=f'```ÏãúÏä§ÌÖúÏù¥ Îã§Ïö¥Î°úÎìúÎêòÏñ¥ ÏûàÏäµÎãàÎã§.```', color=colors['RED'])
            await ctx.send(embed=embed)

@app.command()
async def Î®ºÎç∞Ïù¥(ctx, *, text=None):
    if text != None:
        tag, txt = await get_pattern(text)
        inputValue = tag, txt

    else: 
        inputValue = None
        tag = None

    msg = await get_response(inputValue)

    if tag not in mappings:
        await ctx.send(msg)

    if tag in mappings: 
        code = f'{mappings[tag]}(ctx,txt)'
        await eval(code)

#Check Unknown command and Handler error command
@app.event
async def on_command_error(ctx, error):
    if type(error) == nextcord.ext.commands.errors.CommandNotFound: 
        pass
    else: 
        print(error)

@app.event
async def on_member_join(user): 
    with open('guild.json', 'r', encoding="UTF-8") as g:
            data_guild = json.load(g)

    if data_guild[str(user.guild.id)]["JOIN"]["CHANNEL"] != None:
        txt = data_guild[str(user.guild.id)]["JOIN"]["MESSAGE"]

        if '(Í∏∞Î≥∏Í∞í)' in txt: 
            txt = txt.split(' (Í∏∞Î≥∏Í∞í)')[0]

        channel = app.get_channel(int(data_guild[str(user.guild.id)]['JOIN']["CHANNEL"]))
        #await channel.send(f'{user.mention}Îãò ÏïàÎÖïÌïòÏÑ∏Ïöî')
        await channel.send(eval("f\'"+f'{txt}'+"\'"))

        embed = nextcord.Embed(title="ÏûÖÏû•", description='ÏÑúÎ≤ÑÏóê ÏûÖÏû•ÌïòÏÖ®ÏäµÎãàÎã§.')
        embed.add_field(name='**Ïú†Ï†Ä**', value=f'```{user}```', inline=True)
        embed.set_author(name=f'{user}', icon_url=user.display_avatar)   
        embed.set_footer(text=f"{user.guild.name} | ID : {user.id}")
        await logging(str(user.guild.id), embed=embed, event='ÏÑúÎ≤Ñ ÏûÖÏû•')

@app.event
async def on_member_remove(user): 
    with open('guild.json', 'r', encoding="UTF-8") as g:
            data_guild = json.load(g)

    if data_guild[str(user.guild.id)]["EXIT"]["CHANNEL"] != None:
        txt = data_guild[str(user.guild.id)]["EXIT"]["MESSAGE"]

        if '(Í∏∞Î≥∏Í∞í)' in txt: 
            txt = txt.split(' (Í∏∞Î≥∏Í∞í)')[0]

        channel = app.get_channel(int(data_guild[str(user.guild.id)]['EXIT']["CHANNEL"]))
        #await channel.send(f'{user.mention}Îãò ÏïàÎÖïÌûà Í∞ÄÏÑ∏Ïöî')
        await channel.send(eval("f\'"+f'{txt}'+"\'"))

        embed = nextcord.Embed(title="Ìá¥Ïû•", description='ÏÑúÎ≤ÑÏóêÏÑú Ìá¥Ïû•ÌïòÏÖ®ÏäµÎãàÎã§.')
        embed.add_field(name='**Ïú†Ï†Ä**', value=f'```{user}```', inline=True)
        embed.set_author(name=f'{user}', icon_url=user.display_avatar)   
        embed.set_footer(text=f"{user.guild.name} | ID : {user.id}")
        await logging(str(user.guild.id), 'ÏÑúÎ≤Ñ Ìá¥Ïû•', embed=embed)

@app.event
async def on_voice_state_update(member, before, after): 
    if before.channel == None:
        beforeMembers = 0

    else: 
        beforeMembers = len(before.channel.members)

    if after.channel == None:
        afterMembers = 0

    else:
        afterMembers = len(after.channel.members)

    if afterMembers > beforeMembers:
        event = 'join'

    
    elif afterMembers < beforeMembers:
        event = 'leave'

    elif afterMembers == 0: 
        event = 'leave'
        
    if event == 'join':
        embed = nextcord.Embed(title="ÏûÖÏû•", description='Î≥¥Ïù¥Ïä§ Ï±ÑÎÑêÏóê ÏûÖÏû•ÌïòÏÖ®ÏäµÎãàÎã§.')
        embed.add_field(name='**Ïú†Ï†Ä**', value=f'```{member}```', inline=True)
        embed.add_field(name='**Ï±ÑÎÑê**', value=f'{after.channel.mention if after.channel != None else before.channel.mention}', inline=True)
        embed.set_author(name=f'{member}', icon_url=member.avatar if member.avatar != None else member.display_avatar)   
        embed.set_footer(text=f"{member.guild.name} | ID : {member.id}")
        await logging(str(member.guild.id), 'Î≥¥Ïù¥Ïä§ Ï±ÑÎÑê ÏûÖÏû•', embed=embed)

    else: 
        embed = nextcord.Embed(title="Ìá¥Ïû•", description='Î≥¥Ïù¥Ïä§ Ï±ÑÎÑêÏóêÏÑú Ìá¥Ïû•ÌïòÏÖ®ÏäµÎãàÎã§.')
        embed.add_field(name='**Ïú†Ï†Ä**', value=f'```{member}```', inline=True)
        embed.add_field(name='**Ï±ÑÎÑê**', value=f'{before.channel.mention if before.channel != None else after.channel.mention}', inline=True)
        embed.set_author(name=f'{member}', icon_url=member.avatar if member.avatar != None else member.display_avatar)   
        embed.set_footer(text=f"{member.guild.name} | ID : {member.id}")
        await logging(str(member.guild.id), 'Î≥¥Ïù¥Ïä§ Ï±ÑÎÑê Ìá¥Ïû•', embed=embed)

@app.event
async def on_message_delete(message): 
    entry = await message.guild.audit_logs(action=nextcord.AuditLogAction.message_delete, limit=1).get()

    if message.author.bot != True:
        embed = nextcord.Embed(title="Î©îÏÑ∏ÏßÄ ÏÇ≠Ï†ú", description='Î©îÏÑ∏ÏßÄÍ∞Ä ÏÇ≠Ï†úÎêòÏóàÏäµÎãàÎã§.')
        embed.add_field(name='**Ï†ÑÏÜ°Ìïú Ïú†Ï†Ä**', value=f'```{message.author}```', inline=True)
        embed.add_field(name='**Ï±ÑÎÑê**', value=f'{message.channel.mention}', inline=True)
        embed.add_field(name='**ÏÇ≠Ï†úÎêú Î©îÏÑ∏ÏßÄ**', value=f'```{message.content}```', inline=False)
        embed.set_author(name=f'{entry.user}', icon_url=entry.user.avatar if entry.user.avatar != None else entry.user.display_avatar)   
        embed.set_footer(text=f"{entry.guild.name} | ID : {entry.user.id}")
        await logging(str(entry.guild.id), 'Î©îÏÑ∏ÏßÄ ÏÇ≠Ï†ú', embed=embed)

@app.event
async def on_message_edit(before, after): 
    if after.author.bot != True:
        embed = nextcord.Embed(title="Î©îÏÑ∏ÏßÄ ÏàòÏ†ï", description='Î©îÏÑ∏ÏßÄÍ∞Ä ÏàòÏ†ïÎêòÏóàÏäµÎãàÎã§.')
        embed.add_field(name='**ÏàòÏ†ïÌïú Ïú†Ï†Ä**', value=f'```{after.author}```', inline=True)
        embed.add_field(name='**Ï±ÑÎÑê**', value=f'{after.channel.mention}', inline=True)
        embed.add_field(name='**Î≥ÄÍ≤Ω Ï†Ñ Î©îÏÑ∏ÏßÄ**', value=f'```{before.content}```', inline=False)
        embed.add_field(name='**Î≥ÄÍ≤Ω ÌõÑ Î©îÏÑ∏ÏßÄ**', value=f'```{after.content}```', inline=False)
        embed.set_author(name=f'{after.author}', icon_url=after.author.avatar if after.author.avatar != None else after.author.display_avatar)   
        embed.set_footer(text=f"{after.guild.name} | ID : {after.author.id}")
        await logging(str(after.guild.id), 'Î©îÏÑ∏ÏßÄ ÏàòÏ†ï', embed=embed)

@app.event
async def on_guild_channel_create(channel):
    entry = await channel.guild.audit_logs(action=nextcord.AuditLogAction.channel_create, limit=1).get()
    if entry.user.bot != True:
        embed = nextcord.Embed(title="Ï±ÑÎÑê ÏÉùÏÑ±", description='Ï±ÑÎÑêÏù¥ ÏÉùÏÑ±ÎêòÏóàÏäµÎãàÎã§.')
        embed.add_field(name='**Ïú†Ï†Ä**', value=f'```{entry.user}```', inline=True)
        embed.add_field(name='**Ï±ÑÎÑê**', value=f'{channel.mention}', inline=True)
        embed.set_author(name=f'{entry.user}', icon_url=entry.user.avatar if entry.user.avatar != None else entry.user.display_avatar)   
        embed.set_footer(text=f"{channel.guild.name} | ID : {entry.user.id}")
        await logging(str(channel.guild.id), 'Ï±ÑÎÑê ÏÉùÏÑ±', embed=embed)

@app.event
async def on_guild_channel_delete(channel): 
    entry = await channel.guild.audit_logs(action=nextcord.AuditLogAction.channel_delete, limit=1).get()
    if entry.user.bot != True:
        embed = nextcord.Embed(title="Ï±ÑÎÑê ÏÇ≠Ï†ú", description='Ï±ÑÎÑêÏù¥ ÏÇ≠Ï†úÎêòÏóàÏäµÎãàÎã§.')
        embed.add_field(name='**Ïú†Ï†Ä**', value=f'```{entry.user}```', inline=True)
        embed.add_field(name='**Ï±ÑÎÑê**', value=f'```{channel}```', inline=True)
        embed.set_author(name=f'{entry.user}', icon_url=entry.user.avatar if entry.user.avatar != None else entry.user.display_avatar)   
        embed.set_footer(text=f"{channel.guild.name} | ID : {entry.user.id}")
        await logging(str(channel.guild.id), 'Ï±ÑÎÑê ÏÇ≠Ï†ú', embed=embed)

@app.event
async def on_member_update(before, after): 
    user = after
    log = await after.guild.audit_logs(action=nextcord.AuditLogAction.member_update, limit=1).get()

    if len(before.roles) < len(after.roles):
        newRole = next(role for role in after.roles if role not in before.roles)

        embed = nextcord.Embed(title="Ïó≠Ìï† Ï∂îÍ∞Ä", description='Ïó≠Ìï†Ïù¥ Ï∂îÍ∞ÄÎêòÏóàÏäµÎãàÎã§.')
        embed.add_field(name='**Ïú†Ï†Ä**', value=f'```{user}```', inline=True)
        embed.add_field(name='**Ïó≠Ìï†**', value=f'```{newRole}```', inline=True)
        embed.set_author(name=f'{log.user}', icon_url=log.user.avatar if log.user.avatar != None else log.user.display_avatar)   
        embed.set_footer(text=f"{after.guild.name} | ID : {log.user.id}")
        await logging(str(after.guild.id), 'Ïú†Ï†Ä Ïó≠Ìï† Î≥ÄÍ≤Ω', embed=embed)

    elif len(before.roles) > len(after.roles): 
        oldRole = next(role for role in before.roles if role not in after.roles)

        embed = nextcord.Embed(title="Ïó≠Ìï† Ï†úÍ±∞", description='Ïó≠Ìï†Ïù¥ Ï†úÍ±∞ÎêòÏóàÏäµÎãàÎã§.')
        embed.add_field(name='**Ïú†Ï†Ä**', value=f'```{user}```', inline=True)
        embed.add_field(name='**Ïó≠Ìï†**', value=f'```{oldRole}```', inline=True)
        embed.set_author(name=f'{log.user}', icon_url=log.user.avatar if log.user.avatar != None else log.user.display_avatar)   
        embed.set_footer(text=f"{after.guild.name} | ID : {log.user.id}")
        await logging(str(after.guild.id), 'Ïú†Ï†Ä Ïó≠Ìï† Î≥ÄÍ≤Ω', embed=embed)

    elif before.nick != after.nick: 
        if after.nick == None: 
            after.nick = after.name

        if before.nick == None:
            before.nick = before.name

        embed = nextcord.Embed(title="Î≥ÑÎ™Ö Î≥ÄÍ≤Ω", description='Î≥ÑÎ™ÖÏù¥ Î≥ÄÍ≤ΩÎêòÏóàÏäµÎãàÎã§.')
        embed.add_field(name='**Ïú†Ï†Ä**', value=f'```{user}```', inline=True)
        embed.add_field(name='**Î≥ÄÍ≤Ω Ï†Ñ Î≥ÑÎ™Ö**', value=f'```{before.nick}```', inline=False)
        embed.add_field(name='**Î≥ÄÍ≤Ω ÌõÑ Î≥ÑÎ™Ö**', value=f'```{after.nick}```', inline=True)
        embed.set_author(name=f'{log.user}', icon_url=log.user.avatar if log.user.avatar != None else log.user.display_avatar)   
        embed.set_footer(text=f"{after.guild.name} | ID : {log.user.id}")
        await logging(str(after.guild.id), 'Ïú†Ï†Ä ÎãâÎÑ§ÏûÑ Î≥ÄÍ≤Ω', embed=embed)

@app.event
async def on_guild_role_create(role):
    log = await role.guild.audit_logs(action=nextcord.AuditLogAction.role_create, limit=1).get()

    embed = nextcord.Embed(title="Ïó≠Ìï† ÏÉùÏÑ±", description='Ïó≠Ìï†Ïù¥ ÏÉùÏÑ±ÎêòÏóàÏäµÎãàÎã§.')
    embed.add_field(name='**Ïó≠Ìï†**', value=f'```{role}```', inline=True)
    embed.set_author(name=f'{log.user}', icon_url=log.user.avatar if log.user.avatar != None else log.user.display_avatar)   
    embed.set_footer(text=f"{role.guild.name} | ID : {log.user.id}")
    await logging(str(role.guild.id), 'Ïó≠Ìï† ÏÉùÏÑ±', embed=embed)

@app.event
async def on_guild_role_delete(role):
    log = await role.guild.audit_logs(action=nextcord.AuditLogAction.role_delete, limit=1).get()

    embed = nextcord.Embed(title="Ïó≠Ìï† ÏÇ≠Ï†ú", description='Ïó≠Ìï†Ïù¥ ÏÇ≠Ï†úÎêòÏóàÏäµÎãàÎã§.')
    embed.add_field(name='**Ïó≠Ìï†**', value=f'```{role}```', inline=True)
    embed.set_author(name=f'{log.user}', icon_url=log.user.avatar if log.user.avatar != None else log.user.display_avatar)   
    embed.set_footer(text=f"{role.guild.name} | ID : {log.user.id}")
    await logging(str(role.guild.id), 'Ïó≠Ìï† ÏÇ≠Ï†ú', embed=embed)

@app.event
async def on_guild_role_update(before, after):
    log = await after.guild.audit_logs(action=nextcord.AuditLogAction.role_update, limit=1).get()

    if before.name != after.name: 
        embed = nextcord.Embed(title="Ïó≠Ìï† Ïù¥Î¶Ñ Î≥ÄÍ≤Ω", description='Ïó≠Ìï† Ïù¥Î¶ÑÏù¥ Î≥ÄÍ≤ΩÎêòÏóàÏäµÎãàÎã§.')
        embed.add_field(name='**Î≥ÄÍ≤Ω Ï†Ñ Ïù¥Î¶Ñ**', value=f'```{before.name}```', inline=True)
        embed.add_field(name='**Î≥ÄÍ≤Ω ÌõÑ Ïù¥Î¶Ñ**', value=f'```{after.name}```', inline=True)
        embed.set_author(name=f'{log.user}', icon_url=log.user.avatar if log.user.avatar != None else log.user.display_avatar)   
        embed.set_footer(text=f"{after.guild.name} | ID : {log.user.id}")
        await logging(str(after.guild.id), 'Ïó≠Ìï† Ïù¥Î¶Ñ Î≥ÄÍ≤Ω',  embed=embed)

    elif before.colour != after.colour:
        embed = nextcord.Embed(title="Ïó≠Ìï† ÏÉâÏÉÅ Î≥ÄÍ≤Ω", description='Ïó≠Ìï† ÏÉâÏÉÅÏù¥ Î≥ÄÍ≤ΩÎêòÏóàÏäµÎãàÎã§.')
        embed.add_field(name='**Î≥ÄÍ≤Ω Ï†Ñ ÏÉâÏÉÅ**', value=f'```{before.colour}```', inline=True)
        embed.add_field(name='**Î≥ÄÍ≤Ω ÌõÑ ÏÉâÏÉÅ**', value=f'```{after.colour}```', inline=True)
        embed.set_author(name=f'{log.user}', icon_url=log.user.avatar if log.user.avatar != None else log.user.display_avatar)   
        embed.set_footer(text=f"{log.guild.name} | ID : {log.user.id}")
        await logging(str(log.guild.id), 'Ïó≠Ìï† ÏÉâÏÉÅ Î≥ÄÍ≤Ω', embed=embed)

@app.event
async def on_member_ban(guild, user):
    log = await guild.audit_logs(action=nextcord.AuditLogAction.ban, limit=1).get()

    embed = nextcord.Embed(title="Ïú†Ï†Ä Ï∞®Îã®", description='Ïú†Ï†ÄÍ∞Ä Ï∞®Îã®ÎêòÏóàÏäµÎãàÎã§.')
    embed.add_field(name='**Ïú†Ï†Ä**', value=f'```{user}```', inline=True)
    embed.set_author(name=f'{log.user}', icon_url=log.user.avatar if log.user.avatar != None else log.user.display_avatar)   
    embed.set_footer(text=f"{log.guild.name} | ID : {log.user.id}")
    await logging(str(log.guild.id), 'Ïú†Ï†Ä Ï∞®Îã®',  embed=embed)

@app.event
async def on_member_unban(guild, user): 
    log = await guild.audit_logs(action=nextcord.AuditLogAction.unban, limit=1).get()

    embed = nextcord.Embed(title="Ïú†Ï†Ä Ï∞®Îã® Ìï¥Ï†ú", description='Ïú†Ï†ÄÏùò Ï∞®Îã®Ïù¥ Ìï¥Ï†úÎêòÏóàÏäµÎãàÎã§.')
    embed.add_field(name='**Ïú†Ï†Ä**', value=f'```{user}```', inline=True)
    embed.set_author(name=f'{log.user}', icon_url=log.user.avatar if log.user.avatar != None else log.user.display_avatar)   
    embed.set_footer(text=f"{log.guild.name} | ID : {log.user.id}")
    await logging(str(log.guild.id), 'Ïú†Ï†Ä Ï∞®Îã® Ìï¥Ï†ú', embed=embed)

@app.event
async def on_invite_create(invite):
    log = await invite.guild.audit_logs(action=nextcord.AuditLogAction.invite_create, limit=1).get()

    date_diff = invite.expires_at - invite.created_at
    day = int(date_diff.days)	
    hour = int(date_diff.seconds / 3600)
    minute = int(date_diff.seconds / 60)
    sec = int(date_diff.seconds) - minute*60 

    if day != 0 and hour != 0:
        date = f'{day}Ïùº {hour}ÏãúÍ∞Ñ ÌõÑ'

    else: 
        date = f'{minute}Î∂Ñ {sec}Ï¥à ÌõÑ'

    embed = nextcord.Embed(title="Ï¥àÎåÄÏΩîÎìú ÏÉùÏÑ±", description='Ï¥àÎåÄÏΩîÎìúÍ∞Ä ÏÉùÏÑ±ÎêòÏóàÏäµÎãàÎã§.')
    embed.add_field(name='**ÏÉùÏÑ± Ïú†Ï†Ä**', value=f'```{log.user}```', inline=True)
    embed.add_field(name='**Ï±ÑÎÑê**', value=f'```{invite.channel}```', inline=True)
    embed.add_field(name='**ÎßåÎ£å**', value=f'```{date}```', inline=False)
    embed.add_field(name='**Ï¥àÎåÄÏΩîÎìú**', value=f'```{invite}```', inline=False)
    embed.set_author(name=f'{log.user}', icon_url=log.user.avatar if log.user.avatar != None else log.user.display_avatar)   
    embed.set_footer(text=f"{log.guild.name} | ID : {log.user.id}")
    await logging(str(log.guild.id), 'Ï¥àÎåÄÏΩîÎìú ÏÉùÏÑ±', embed=embed)
   
@app.event
async def on_invite_delete(invite):
    log = await invite.guild.audit_logs(action=nextcord.AuditLogAction.invite_delete, limit=1).get()

    embed = nextcord.Embed(title="Ï¥àÎåÄÏΩîÎìú ÏÇ≠Ï†ú", description='Ï¥àÎåÄÏΩîÎìúÍ∞Ä ÏÇ≠Ï†úÎêòÏóàÏäµÎãàÎã§.')
    embed.add_field(name='**Ï±ÑÎÑê**', value=f'```{invite.channel}```', inline=True)
    embed.add_field(name='**ÏÇ¨Ïö©**', value=f'```{invite.uses if invite.uses != None else 0}Ìöå```', inline=True)
    embed.add_field(name='**Ï¥àÎåÄÏΩîÎìú**', value=f'```{invite}```', inline=False)
    embed.set_author(name=f'{log.user}', icon_url=log.user.avatar if log.user.avatar != None else log.user.display_avatar)   
    embed.set_footer(text=f"{log.guild.name} | ID : {log.user.id}")
    await logging(str(log.guild.id), 'Ï¥àÎåÄÏΩîÎìú ÏÇ≠Ï†ú', embed=embed)

@app.event
async def on_message(message):
    if str(message.channel.type) == 'private':
        embed = nextcord.Embed(title='Ïò§Î•ò', description='```Í∞úÏù∏Ï†ÅÏù∏ ÎåÄÌôîÎäî Í≥§ÎûÄÌï¥Ïöî!```', color=colors['RED'])
        user = message.author
        try:
            await user.send(embed=embed)  
        
        except: 
            pass

    else:
        if message.author.bot == False:
            if str(message.guild.id) in guilds: 
                badwords = ['ÏãúÎ∞ú', 'Ïî®Î∞ú', 'Ï°¥ÎÇò']

                for badword in badwords:
                    if message.content.find(badword) != -1:
                        await message.delete()
                        await message.channel.send(f"{message.author.mention} ÏöïÏùÄ ÎÇòÏÅúÍ≤ÅÎãàÎã§!")
                        return # So that it doesn't try to delete the message again.

                await app.process_commands(message)

            else: 
                if 'ÏÖãÏóÖ' == message.content: 
                    await app.process_commands(message)

                try:
                    if 'Î®ºÎç∞Ïù¥' in str(message.content).split()[0]:
                        embed = nextcord.Embed(description='ÏãúÏä§ÌÖúÏù¥ Îã§Ïö¥Î°úÎìúÎêòÏñ¥ ÏûàÏßÄ ÏïäÏùÄ ÏÑúÎ≤ÑÏûÖÎãàÎã§. Î®ºÎç∞Ïù¥Î•º Ïù¥Ïö©ÌïòÏãúÎ†§Î©¥ `ÏÖãÏóÖ`ÏùÑ ÌÜµÌï¥ ÌôúÏÑ±ÌôîÌï¥Ï£ºÏÑ∏Ïöî', color=colors['RED'])
                        await message.channel.send(embed=embed)

                except IndexError: 
                    if 'Î®ºÎç∞Ïù¥' == str(message.content).split()[0]:
                        embed = nextcord.Embed(description='ÏãúÏä§ÌÖúÏù¥ Îã§Ïö¥Î°úÎìúÎêòÏñ¥ ÏûàÏßÄ ÏïäÏùÄ ÏÑúÎ≤ÑÏûÖÎãàÎã§. Î®ºÎç∞Ïù¥Î•º Ïù¥Ïö©ÌïòÏãúÎ†§Î©¥ `ÏÖãÏóÖ`ÏùÑ ÌÜµÌï¥ ÌôúÏÑ±ÌôîÌï¥Ï£ºÏÑ∏Ïöî', color=colors['RED'])
                        await message.channel.send(embed=embed)

#activate
app.run(token)